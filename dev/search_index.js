var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LatticeUtilities]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [LatticeUtilities]","category":"page"},{"location":"api/#LatticeUtilities.Bond","page":"API","title":"LatticeUtilities.Bond","text":"Bond{D}\n\nDefines a bond in a D dimensional lattice.\n\nFields\n\norbitals::NTuple{2,Int}: Orbital pair associated with bond. Bond goes from orbitals[1] to orbitals[2].\ndisplacement::SVector{D,Int}: Displacement in unit cells in the direction of each lattice vector associated with bond.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.Bond-Tuple{Any, Any}","page":"API","title":"LatticeUtilities.Bond","text":"Bond(orbitals, displacement)\n\nBond(; orbitals, displacement)\n\nConstruct a Bond\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.Lattice","page":"API","title":"LatticeUtilities.Lattice","text":"Lattice{D}\n\nA type defining a finite lattice in D dimensions.\n\nFields\n\nN::Int: Number of unit cells in finite lattice.\nL::SVector{D,Int}: Size of finite lattice in the direction of each lattice vector in unit cells.\nperiodic::SVector{D,Bool}: Specifies whether each lattice vector direction hosts periodic or open boundary conditions.\nlvec::MVector{D,Int}: (private) Temporary storage vector containing intermediate location and displacement vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.Lattice-Tuple{Any, Any}","page":"API","title":"LatticeUtilities.Lattice","text":"Lattice(L, periodic)\n\nLattice(; L, periodic)\n\nConstructs a Lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.UnitCell","page":"API","title":"LatticeUtilities.UnitCell","text":"UnitCell{D,n,T<:AbstractFloat,N}\n\nA type defining a unit cell in D spatial dimensions.\n\nFields\n\nn::Int: Number of orbitals in the unit cell.\nlattice_vecs::SMatrix{D,D,T,N}: Matrix where columns give the lattice vectors.\nreciprocal_vecs::SMatrix{D,D,T,N}: Matrix where columns give the reciprocal lattice vectors.\nbasis_vecs::Vector{SVector{D,T}}: Vector of basis vectors specifying the location of each orbital in unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.UnitCell-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"API","title":"LatticeUtilities.UnitCell","text":"UnitCell(lattice_vecs::AbstractMatrix{T}, basis_vecs::AbstractMatrix{T}) where {T<:AbstractFloat}\n\nUnitCell(lattice_vecs::AbstractVector{Vector{T}}, basis_vecs::AbstractVector{Vector{T}}) where {T<:AbstractFloat}\n\nUnitCell(; lattice_vecs, basis_vecs)\n\nReturns an instance of the type UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Union{Tuple{D2}, Tuple{D1}, Tuple{Bond{D1}, Bond{D2}}} where {D1, D2}","page":"API","title":"Base.:==","text":"Base.:(==)(b1::Bond{D1}, b2::Bond{D2}) where {D1, D2}\n\nTests if two bonds b1 and b2 are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ndims-Union{Tuple{UnitCell{D}}, Tuple{D}} where D","page":"API","title":"Base.ndims","text":"Base.ndims(unit_cell::UnitCell{D}) where {D}\n\nBase.ndims(lattice::Lattice{D}) where {D}\n\nBase.ndims(bond::Bond{D}) where {D}\n\nReturn the spatial dimensions of a UnitCell, Lattice or Bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{D}, Tuple{IO, Bond{D}}} where D","page":"API","title":"Base.show","text":"Base.show(io::IO, bond::Bond{D}) where {D}\n\nBase.show(io::IO, ::MIME\"text/plain\", bond::Bond{D}) where {D}\n\nShow lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{D}, Tuple{IO, Lattice{D}}} where D","page":"API","title":"Base.show","text":"Base.show(io::IO, lattice::Lattice{D}) where {D}\n\nBase.show(io::IO, ::MIME\"text/plain\", lattice::Lattice{D}) where {D}\n\nShow lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{D}, Tuple{IO, UnitCell{D, T}}} where {D, T}","page":"API","title":"Base.show","text":"Base.show(io::IO, uc::UnitCell{D,T}) where {D,T}\n\nBase.show(io::IO, ::MIME\"text/plain\", uc::UnitCell{D,T}) where {D,T}\n\nShow unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.bond_to_vec!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Bond{D}, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.bond_to_vec!","text":"bond_to_vec!(Δr::AbstractVector{T}, bond::Bond{D}, unit_cell::UnitCell{D,T}) where {D,T}\n\nCalculate the displacement vector associated with a bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.bond_to_vec-Union{Tuple{T}, Tuple{D}, Tuple{Bond{D}, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.bond_to_vec","text":"bond_to_vec(bond::Bond{D}, unit_cell::UnitCell{D,T}) where {D,T}\n\nReturn the displacement vector associated with a bond as SVector{D,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.build_neighbor_table-Union{Tuple{D}, Tuple{Any, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.build_neighbor_table","text":"build_neighbor_table(bonds, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nConstruct the neighbor table corresponding bonds, a tuple/vector of Bond defintions.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.build_neighbor_table-Union{Tuple{D}, Tuple{Bond{D}, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.build_neighbor_table","text":"build_neighbor_table(bond::Bond{D}, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nConstruct the neighbor table corresponding to bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_point!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, AbstractVector{Int64}, UnitCell{D, T}, Lattice{D}}} where {D, T}","page":"API","title":"LatticeUtilities.calc_k_point!","text":"calc_k_point!(k_point::AbstractVector{T}, k_loc::AbstractVector{Int},\n              unit_cell::UnitCell{D,T}, lattice::Lattice{D}) where {D,T}\n\nCalculate the k-point k_point corresponding to the k-point location k_loc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_point-Union{Tuple{T}, Tuple{D}, Tuple{Any, UnitCell{D, T}, Lattice{D}}} where {D, T}","page":"API","title":"LatticeUtilities.calc_k_point","text":"calc_k_point(k_loc, unit_cell::UnitCell{D,T}, lattice::Lattice{D}) where {D,T}\n\nReturn the k-point corresponding to the k-point location k_loc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_points!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T}, UnitCell{D, T}, Lattice{D}}} where {D, T}","page":"API","title":"LatticeUtilities.calc_k_points!","text":"calc_k_points!(k_points::AbstractArray{T}, unit_cell::UnitCell{D,T}, lattice::Lattice{D}) where {D,T}\n\nCalculate the k-point grid k_points assicated with a finite lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_points-Union{Tuple{T}, Tuple{D}, Tuple{UnitCell{D, T}, Lattice{D}}} where {D, T}","page":"API","title":"LatticeUtilities.calc_k_points","text":"calc_k_points(unit_cell::UnitCell{D,T}, lattice::Lattice{D}) where {D,T}\n\nReturn the k-points associated with a finite lattice as a vector of static vectors, Vector{SVector{D,T}}. If the system has open boundary conditions in a given direction, it will treat the linear extent of the system in that direction as equalling L=1 for the purposes of calculating the k-points.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.displacement_to_vec!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Any, Int64, Int64, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.displacement_to_vec!","text":"displacement_to_vec!(Δr::AbstractVector{T}, Δl, o_init::Int, o_final::Int, unit_cell::UnitCell{D,T}) where {D,T}\n\nComputes the position space displacement vector Δr corresponding to a displacement definition given by initial and final orbitals o₁ and o₂ in the unit cell respectively, along with a displacement in unit cells Δl.\n\nArguments\n\nΔr::AbstractVector{T}: displacement vector in position space.\nΔl: displacement in unit cells.\no_init::Int: initial orbital in unit cell.\no_final::Int: final orbital in unit cell.\nunit_cell::UnitCell{D,T}: unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.displacement_to_vec-Union{Tuple{T}, Tuple{D}, Tuple{Any, Int64, Int64, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.displacement_to_vec","text":"displacement_to_vec(Δl, o_init::Int, o_final::Int, unit_cell::UnitCell{D,T})::SVector{D,T} where {D,T}\n\nReturns the position space displacement vector Δr corresponding to a displacement definition given by initial and final orbitals o_init and o_final in the unit cell respectively, along with a displacement in unit cells Δl.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Any, Int64, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.loc_to_pos!","text":"loc_to_pos!(r::AbstractVector{T}, l, o::Int, unit_cell::UnitCell{D,T}) where {D,T}\n\nCalculate the position r of an orbital o at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractVector{T}, Any, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.loc_to_pos!","text":"loc_to_pos!(r::AbstractVector{T}, l, unit_cell::UnitCell{D,T}) where {D,T}\n\nCalculate the position r of a unit cell at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos-Union{Tuple{T}, Tuple{D}, Tuple{Any, Int64, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.loc_to_pos","text":"loc_to_pos(l, s::Int, unit_cell::UnitCell{D,T}) where {D,T}\n\nReturn the position r of a orbital o at location l as a vector or type SVector{D,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos-Union{Tuple{T}, Tuple{D}, Tuple{Any, UnitCell{D, T}}} where {D, T}","page":"API","title":"LatticeUtilities.loc_to_pos","text":"loc_to_pos(l, unit_cell::UnitCell{T}) where {T}\n\nReturn the position r of a unit cell at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_site-Union{Tuple{D}, Tuple{Any, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.loc_to_site","text":"loc_to_site(l, o::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nGiven a unit cell location l and orbital species o, return the corresponding site s in the lattice. If the location is not valid owing to open boundary conditions then return s = 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_site-Union{Tuple{D}, Tuple{Int64, Int64, UnitCell{D}}} where D","page":"API","title":"LatticeUtilities.loc_to_site","text":"loc_to_site(u::Int, o::Int, unit_cell::UnitCell{D}) where {D}\n\nGiven a unit cell index u and orbital o, return the correspond site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_unitcell-Union{Tuple{D}, Tuple{Any, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.loc_to_unitcell","text":"loc_to_unitcell(l, lattice::Lattice{D}) where {D}\n\nReturn the unit cell found at location l in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.map_neighbor_table-Tuple{Matrix{Int64}}","page":"API","title":"LatticeUtilities.map_neighbor_table","text":"map_neighbor_table(neighbor_table::Matrix{Int})\n\nFor a given neighbor table, return a dictionary that reports the bonds and neighbors associated with each site in the lattice. If neighbor_table is modified, then a new map must be constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.norbits-Tuple{UnitCell}","page":"API","title":"LatticeUtilities.norbits","text":"norbits(unit_cell::UnitCell)\n\nReturn the number of orbitals in a unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.nsites-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.nsites","text":"nsites(unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nnsites(; unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nReturn the total number of sites/orbitals in a finite lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.pbc!-Union{Tuple{D}, Tuple{AbstractVector{Int64}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.pbc!","text":"pbc!(l::AbstractVector{Int}, lattice::Lattice{D}) where {D}\n\nApply periodic boundary to unit cell location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.simplify!-Union{Tuple{D}, Tuple{AbstractVector{Int64}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.simplify!","text":"simplify!(Δl::AbstractVector{Int}, lattice::Lattice{D}) where {D}\n\nSimplify displacement Δl so that it is as short as possible accounting for periodic boundary conditions where necessary.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.simplify-Union{Tuple{D}, Tuple{Bond{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.simplify","text":"simplify(bond::Bond{D}, lattice::Lattice{D}) where {D}\n\nSimplify a bond so that the displacement is the shortest possible accounting for periodic boundary conditions where necessary, returning the new bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_loc!-Union{Tuple{D}, Tuple{AbstractVector{Int64}, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.site_to_loc!","text":"site_to_loc!(l::AbstractVector{Int}, s::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nsite_to_loc!(; l::AbstractVector{Int}, s::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nFor a given site s in the lattice, calculate the location l of the unit cell it is in and return the orbital species o of the site.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_loc-Union{Tuple{T}, Tuple{D}, Tuple{Int64, UnitCell{D, T}, Lattice{D}}} where {D, T}","page":"API","title":"LatticeUtilities.site_to_loc","text":"site_to_loc(s::Int, unit_cell::UnitCell{D,T}, lattice::Lattice{D}) where {D,T}\n\nFor a given site s in the lattice, return the location l of the unit cell it is in and the orbital species o.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_orbital-Tuple{Int64, UnitCell}","page":"API","title":"LatticeUtilities.site_to_orbital","text":"site_to_orbital(s::Int, unit_cell::UnitCell)\n\nReturn the orbtial species of site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_site-Union{Tuple{D}, Tuple{Int64, Any, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.site_to_site","text":"site_to_site(s::Int, Δl, o::Int, unit_cell::UnitCell, lattice::Lattice)\n\nGiven an initial site s, and a displacement in unit cells Δl and a terminating orbital species o, return the resulting site s′ in the lattice. If the displacement is not allowed as a result of open boundary conditions, then  s′=0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_unitcell-Tuple{Int64, UnitCell}","page":"API","title":"LatticeUtilities.site_to_unitcell","text":"site_to_unitcell(s::Int, unit_cell::UnitCell)\n\nReturn the unit cell u containing lattice site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_bond-Union{Tuple{D}, Tuple{Int64, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.sites_to_bond","text":"sites_to_bond(s::Int, s′::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nReturn the Bond associated with getting displaced from site s to s′. \n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_displacement!-Union{Tuple{D}, Tuple{AbstractVector{Int64}, Int64, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.sites_to_displacement!","text":"function sites_to_displacement!(Δl::AbstractVector{Int}, s::Int, s′::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nWhen getting displaced from site s to s′, calculate the corresponding displacement in unit cells Δl.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_displacement-Union{Tuple{D}, Tuple{Int64, Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.sites_to_displacement","text":"function sites_to_displacement(s::Int, s′::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nWhen getting displaced from site s to s′, return the corresponding displacement in unit cells Δl::MVector{D,Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.translational_avg!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, AbstractArray{Complex{T}}}} where T<:AbstractFloat","page":"API","title":"LatticeUtilities.translational_avg!","text":"function translational_avg!(fg::AbstractArray{Complex{T}}, f::AbstractArray{Complex{T}}, g::AbstractArray{Complex{T}};\n                            restore::Bool=true) where {T<:AbstractFloat}\n\nLet f[i] and g[j] be two distinct multi-dimensional arrays, where i and j represent an index into them and also correspond to the position of a unit cell in a periodic finite lattice This method then computes in-place the product (f⋅g)[i-j] that is averaged over translation symmetry. If restore = true then f and g are left unchanged, otherwise they will be left modified.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.unitcell_to_loc!-Union{Tuple{D}, Tuple{AbstractVector{Int64}, Int64, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.unitcell_to_loc!","text":"unitcell_to_loc!(l::AbstractVector{Int}, u::Int, lattice::Lattice{D}) where {D}\n\nCalculate the location l of a unit cell u.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.unitcell_to_loc-Union{Tuple{D}, Tuple{Int64, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.unitcell_to_loc","text":"unitcell_to_loc(u::Int, lattice::Lattice{D})::SVector{D,Int} where {D}\n\nReturn the location of unit cell u as an instance of type SVector{D,Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.valid_loc-Union{Tuple{D}, Tuple{Any, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.valid_loc","text":"valid_loc(l, lattice::Lattice{D})::Bool where {D}\n\nDetermine if l describes a valid location in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.valid_site-Union{Tuple{D}, Tuple{Int64, UnitCell{D}, Lattice{D}}} where D","page":"API","title":"LatticeUtilities.valid_site","text":"valid_site(s::Int, unit_cell::UnitCell{D}, lattice::Lattice{D}) where {D}\n\nvalid_site(; s, unit_cell, lattice) = valid_site(s, unit_cell, lattice)\n\nReturn whether s is a valid site index.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First the LatticeUtilities.jl package needs to be imported.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using LatticeUtilities","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As an initial example, we construct an instance of the UnitCell type to represent the unit cell for a square lattice:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> square = UnitCell(lattice_vecs = [[1.,0.],[0.,1.]],\n                         basis_vecs   = [[0.,0.]])\n[UnitCell]\n\ndimensions = 2\norbitals = 1\n\n[UnitCell.lattice_vecs]\n\na_1 = [1.0, 0.0]\na_2 = [0.0, 1.0]\n\n[UnitCell.reciprocal_vecs]\n\nb_1 = [6.283185307179586, 0.0]\nb_2 = [0.0, 6.283185307179586]\n\n[UnitCell.basis_vecs]\n\nb_1 = [0.0, 0.0]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next we construct an instance of the type Lattice that describes the size of a finite lattice for a given unit cell definition. In the example below we assume periodic boundary conditions in the direction of both lattice vectors:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> lattice = Lattice(L = [4,4], periodic = [true,true])\n[Lattice]\n\ndimensions   = 2\nn_unit_cells = 16\nsize         = [4, 4]\nperiodic     = [true, true]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Bonds (or edges) in a lattice are represented by the Bond type. Considering just nearest neighbors, there are two bonds that need to be defined:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> bond_x = Bond(orbitals = (1,1), displacement = [1,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 1]\ndisplacement = [1, 0]\n\njulia> bond_y = Bond((1,1), [0,1])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 1]\ndisplacement = [0, 1]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Using these two bond definitions, we can construct the corresponding neighbor table using the build_neighbor_table method:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> neighbor_table = build_neighbor_table([bond_x,bond_y], square, lattice)\n2×32 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …   8   9  10  11  12  13  14  15  16\n 2  3  4  1  6  7  8  5  10  11  12     12  13  14  15  16   1   2   3   4","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page includes several examples on how to use the LatticeUtilities.jl package.","category":"page"},{"location":"examples/#Kagome-Lattice","page":"Examples","title":"Kagome Lattice","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As a first example we will represent a Kagome lattice. The lattice vectors for the Kagome lattice are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfa_1 = left(10right)\nmathbfa_2 = left(frac12fracsqrt32right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and with three orbitals per unit cell, the basis vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfr_rm 1 = left(00right)\nmathbfr_rm 2 = left(frac120right)\nmathbfr_rm 3 = left(frac14fracsqrt34right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The reciprocal lattice vectors are then","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfb_1 = 2pi left(1-frac1sqrt3right)\nmathbfb_2 = 2pi left(0frac2sqrt3right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We begin by constructing an instance of the type UnitCell to represent the Kagome lattice unit cell:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> kagome = UnitCell(lattice_vecs = [[1.0,0.0], [1/2,√3/2]],\n                         basis_vecs   = [[0.0,0.0], [1/2,0.0], [1/4,√3/4]])\n[UnitCell]\n\ndimensions = 2\norbitals = 3\n\n[UnitCell.lattice_vecs]\n\na_1 = [1.0, 0.0]\na_2 = [0.5, 0.8660254037844386]\n\n[UnitCell.reciprocal_vecs]\n\nb_1 = [6.283185307179586, -3.627598728468436]\nb_2 = [0.0, 7.255197456936872]\n\n[UnitCell.basis_vecs]\n\nb_1 = [0.0, 0.0]\nb_2 = [0.5, 0.0]\nb_3 = [0.25, 0.4330127018922193]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is straightforward to calculate position space vectors of the form mathbfr = n_1 mathbfa_1 + n_2 mathbfa_2 + mathbfr_alpha using the method loc_to_pos, where mathbfr_alpha is one of the three possible basis vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> n₁, n₂, α = 1, 1, 2\n(1, 1, 2)\n\njulia> loc_to_pos([n₁,n₂], α, kagome)\n2-element SVector{2, Float64} with indices SOneTo(2):\n 2.0\n 0.8660254037844386","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Displacement vectors of the form mathbfr = n_1 mathbfa_1 + n_2 mathbfa_2 + (mathbfr_beta - mathbfr_alpha) can also be calculate using the displacement_to_vec method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> n₁, n₂, α, β = 1, 1, 2, 3\n(1, 1, 2, 3)\n\njulia> displacement_to_vec([n₁,n₂], α, β, kagome)\n2-element SVector{2, Float64} with indices SOneTo(2):\n 1.25\n 1.299038105676658","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that there are memory allocation free variants of many methods, such as loc_to_pos! and displacement_to_vec!, with names ending in ! that work by modifying the first array argument in place.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next step is to construct an instance of the type Lattice, which can be used in conjunction with a UnitCell instance of like dimension D, to represent a finite lattice. In this example we will consider a 3 times 3 unit cell Kagome lattice with periodic boundary conditions in the direction of both lattice vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice = Lattice(L = [3,3], periodic = [true,true])\n[Lattice]\n\ndimensions   = 2\nn_unit_cells = 9\nsize         = [3, 3]\nperiodic     = [true, true]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Given an initial site, a displacement in unit cells, and a terminating orbital species, we can calculate the final site using the site_to_site method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> site_to_site(17, (1,1), 2, kagome, lattice)\n20","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The set of relevant mathbfk-points associated with a finite lattice in three dimensions is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mathbfk = fracn_1L_1mathbfb_1 + fracn_2L_2mathbfb_2 + fracn_3L_3mathbfb_3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where each index runs from n_i = 0 1 dots L_i-1.\nThis set of mathbfk-points can be constructed using the calc_k_points method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> calc_k_points(kagome, lattice)\n3×3 Matrix{SVector{2, Float64}}:\n [0.0, 0.0]          [0.0, 2.4184]            [0.0, 4.8368]\n [2.0944, -1.2092]   [2.0944, 1.2092]         [2.0944, 3.6276]\n [4.18879, -2.4184]  [4.18879, -1.34248e-16]  [4.18879, 2.4184]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Individual mathbfk-points can be calculated using the calc_k_point and calc_k_point! methods.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we concern ourselves with just nearest neighbor bonds, we need to define six instances of Bond type:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 = Bond(orbitals = (1,2), displacement = [0,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [0, 0]\n\njulia> bond_2 = Bond((1,3), [0,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 3]\ndisplacement = [0, 0]\n\njulia> bond_3 = Bond((2,3), [0,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [2, 3]\ndisplacement = [0, 0]\n\njulia> bond_4 = Bond((2,1), [1,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [2, 1]\ndisplacement = [1, 0]\n\njulia> bond_5 = Bond((3,1), [0,1])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [3, 1]\ndisplacement = [0, 1]\n\njulia> bond_6 = Bond((3,2), [-1,1])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [3, 2]\ndisplacement = [-1, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we are ready to build the corresponding neighbor table:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> neighbor_table = build_neighbor_table([bond_1, bond_2, bond_3,\n                                              bond_4, bond_5, bond_6],\n                                              kagome, lattice)\n2×54 Matrix{Int64}:\n 1  4  7  10  13  16  19  22  25  1  4  …   3   6   9  12  15  18  21  24  27\n 2  5  8  11  14  17  20  23  26  3  6     17  11  14  26  20  23   8   2   5","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is frequently useful to have a reference that lists the neighbors associated with each site in the lattice, as well as the bonds, which are specified by a column index into neighbor_table. This information is returned by the function map_neighbor_table:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> neighbor_table_map = map_neighbor_table(neighbor_table)\nDict{Int64, NamedTuple{(:bonds, :neighbors), Tuple{Vector{Int64}, Vector{Int64}}}} with 27 entries:\n  5  => (bonds = [2, 20, 29, 54], neighbors = [4, 6, 7, 27])\n  16 => (bonds = [6, 15, 32, 39], neighbors = [17, 18, 14, 9])\n  20 => (bonds = [7, 25, 34, 50], neighbors = [19, 21, 22, 15])\n  12 => (bonds = [13, 22, 40, 49], neighbors = [10, 11, 19, 26])\n  24 => (bonds = [17, 26, 44, 53], neighbors = [22, 23, 4, 2])\n  8  => (bonds = [3, 21, 30, 52], neighbors = [7, 9, 1, 21])\n  17 => (bonds = [6, 24, 33, 46], neighbors = [16, 18, 10, 3])\n  1  => (bonds = [1, 10, 30, 43], neighbors = [2, 3, 8, 21])\n  19 => (bonds = [7, 16, 36, 40], neighbors = [20, 21, 26, 12])\n  22 => (bonds = [8, 17, 34, 41], neighbors = [23, 24, 20, 15])\n  23 => (bonds = [8, 26, 35, 51], neighbors = [22, 24, 25, 18])\n  6  => (bonds = [11, 20, 38, 47], neighbors = [4, 5, 13, 11])\n  11 => (bonds = [4, 22, 31, 47], neighbors = [10, 12, 13, 6])\n  9  => (bonds = [12, 21, 39, 48], neighbors = [7, 8, 16, 14])\n  14 => (bonds = [5, 23, 32, 48], neighbors = [13, 15, 16, 9])\n  3  => (bonds = [10, 19, 37, 46], neighbors = [1, 2, 10, 17])\n  7  => (bonds = [3, 12, 29, 45], neighbors = [8, 9, 5, 27])\n  25 => (bonds = [9, 18, 35, 42], neighbors = [26, 27, 23, 18])\n  4  => (bonds = [2, 11, 28, 44], neighbors = [5, 6, 2, 24])\n  ⋮  => ⋮","category":"page"},{"location":"examples/#Cubic-Lattice-and-Boundary-Conditions","page":"Examples","title":"Cubic Lattice and Boundary Conditions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we consider a simple cubic lattice. As usual, we begin by defining a UnitCell:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> cubic = UnitCell(lattice_vecs = [[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]],\n                        basis_vecs   = [[0.,0.,0.]])\n[UnitCell]\n\ndimensions = 3\norbitals = 1\n\n[UnitCell.lattice_vecs]\n\na_1 = [1.0, 0.0, 0.0]\na_2 = [0.0, 1.0, 0.0]\na_3 = [0.0, 0.0, 1.0]\n\n[UnitCell.reciprocal_vecs]\n\nb_1 = [6.283185307179586, 0.0, 0.0]\nb_2 = [0.0, 6.283185307179586, 0.0]\nb_3 = [0.0, 0.0, 6.283185307179586]\n\n[UnitCell.basis_vecs]\n\nb_1 = [0.0, 0.0, 0.0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next we define four instances of the type Lattice. The first one represents a lattice that is periodic in the direction of all three lattice vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ppp = Lattice([4,4,4],[true,true,true])\n[Lattice]\n\ndimensions   = 3\nn_unit_cells = 64\nsize         = [4, 4, 4]\nperiodic     = [true, true, true]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The second defines a lattice that is periodic only in the direction of the first two lattice vectors, hatmathbfx and hatmathbfy:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ppo = Lattice([4,4,4],[true,true,false])\n[Lattice]\n\ndimensions   = 3\nn_unit_cells = 64\nsize         = [4, 4, 4]\nperiodic     = [true, true, false]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The third defines a lattice that is periodic only in the direction of the first lattice vector, hatmathbfx:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_poo = Lattice([4,4,4],[true,false,false])\n[Lattice]\n\ndimensions   = 3\nn_unit_cells = 64\nsize         = [4, 4, 4]\nperiodic     = [true, false, false]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lastly, we define a lattice with strictly open boundary conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ooo = Lattice([4,4,4],[false,false,false])\n[Lattice]\n\ndimensions   = 3\nn_unit_cells = 64\nsize         = [4, 4, 4]\nperiodic     = [false, false, false]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the set of mathbfk-points generated by the function calc_k_points changes with the boundary conditions. In particular, if a lattice has open boundary conditions in the direction of the lattice vector mathbfa_i, then it treats L_i = 1 when calculating the relevant set of mathbfk-points associated with a lattice:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> size( calc_k_points(cubic,lattice_ppp) )\n(4, 4, 4)\n\njulia> size( calc_k_points(cubic,lattice_ppo) )\n(4, 4, 1)\n\njulia> size( calc_k_points(cubic,lattice_poo) )\n(4, 1, 1)\n\njulia> size( calc_k_points(cubic,lattice_ooo) )\n(1, 1, 1)\n\njulia> calc_k_points(cubic,lattice_ooo)\n1×1×1 Array{SVector{3, Float64}, 3}:\n[:, :, 1] =\n [0.0, 0.0, 0.0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As you can see, in the case that the lattice only has open boundary conditions, then just the mathbfk = 0 point is returned.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next we will consider how the boundary conditions effect how neighbor tables are computed. Considering just nearest neighbors, we have three bonds to define:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_x = Bond(orbitals = (1,1), displacement = [1,0,0])\n[[Bond]]\n\ndimensions   = 3\norbitals     = [1, 1]\ndisplacement = [1, 0, 0]\n\njulia> bond_y = Bond((1,1), [0,1,0])\n[[Bond]]\n\ndimensions   = 3\norbitals     = [1, 1]\ndisplacement = [0, 1, 0]\n\njulia> bond_z = Bond((1,1), [0,0,1])\n[[Bond]]\n\ndimensions   = 3\norbitals     = [1, 1]\ndisplacement = [0, 0, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base on these three bonds, the neighbor table generated using build_neighbor_table will depend on the boundary conditions used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nt_ppp = build_neighbor_table([bond_x,bond_y,bond_z], cubic, lattice_ppp)\n2×192 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  56  57  58  59  60  61  62  63  64\n 2  3  4  1  6  7  8  5  10  11  12      8   9  10  11  12  13  14  15  16\n\njulia> nt_ppo = build_neighbor_table([bond_x,bond_y,bond_z], cubic, lattice_ppo)\n2×176 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  40  41  42  43  44  45  46  47  48\n 2  3  4  1  6  7  8  5  10  11  12     56  57  58  59  60  61  62  63  64\n\njulia> nt_poo = build_neighbor_table([bond_x,bond_y,bond_z], cubic, lattice_poo)\n2×160 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  40  41  42  43  44  45  46  47  48\n 2  3  4  1  6  7  8  5  10  11  12     56  57  58  59  60  61  62  63  64\n\njulia> nt_ooo = build_neighbor_table([bond_x,bond_y,bond_z], cubic, lattice_ooo)\n2×144 Matrix{Int64}:\n 1  2  3  5  6  7   9  10  11  13  14  …  40  41  42  43  44  45  46  47  48\n 2  3  4  6  7  8  10  11  12  14  15     56  57  58  59  60  61  62  63  64","category":"page"},{"location":"examples/#Honeycomb-Lattice-and-Bond-Operations","page":"Examples","title":"Honeycomb Lattice and Bond Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we consider the Honeycomb, or Hexagonal, lattice with just nearest neighbor interactions. The lattice vectors for the honeycomb lattice are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfa_1 =\tleft(frac32fracsqrt32right)\nmathbfa_2 =\tleft(frac32-fracsqrt32right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and basis vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfr_1 =\tleft(00right)\nmathbfr_2 =\tleft(10right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The corresponding reciprocal lattice vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfb_1 =\t2pileft(frac13fracsqrt33right)\nmathbfb_2 =\t2pileft(frac13-fracsqrt33right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As usual, we begin by constructing an instance of the type UnitCell to reflect this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> honeycomb = UnitCell(lattice_vecs = [[3/2,√3/2],[3/2,-√3/2]],\n                            basis_vecs   = [[0.,0.],[1.,0.]])\n[UnitCell]\n\ndimensions = 2\norbitals = 2\n\n[UnitCell.lattice_vecs]\n\na_1 = [1.5, 0.8660254037844386]\na_2 = [1.5, -0.8660254037844386]\n\n[UnitCell.reciprocal_vecs]\n\nb_1 = [2.094395102393195, 3.627598728468436]\nb_2 = [2.0943951023931957, -3.627598728468436]\n\n[UnitCell.basis_vecs]\n\nb_1 = [0.0, 0.0]\nb_2 = [1.0, 0.0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And again, we define an instance of the type Lattice to represent a finite lattice:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice = Lattice([3,3],[true,true])\n[Lattice]\n\ndimensions   = 2\nn_unit_cells = 9\nsize         = [3, 3]\nperiodic     = [true, true]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we consider just nearest neighbor relations, three types of bonds need to be defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 = Bond(orbitals = (1,2), displacement = [0,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [0, 0]\n\njulia> bond_2 = Bond((1,2), [-1,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [-1, 0]\n\njulia> bond_3 = Bond((1,2), [0,-1])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [0, -1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We could just as well define the bonds in this way.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1′ = Bond(orbitals = (1,2), displacement = [0,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [0, 0]\n\njulia> bond_2′ = Bond((2,1), [1,0])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [2, 1]\ndisplacement = [1, 0]\n\njulia> bond_3′ = Bond((2,1), [0,1])\n[[Bond]]\n\ndimensions   = 2\norbitals     = [2, 1]\ndisplacement = [0, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can do equivalency tests between bonds, but note that directionality matters when you perform these tests.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 == bond_1′\ntrue\n\njulia> bond_2 == bond_2′\nfalse\n\njulia> bond_3 == bond_3′\nfalse\n\njulia> bond_1 == bond_2′\nfalse","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that while not explicitly enforced, for comparison operations like this to be valid each bond definition needs to be defined assuming shared lattice vector definitions, which themselves are not unique.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lastly, given a pair of sites in a finite lattice, it is very easy to determine the bond definition connecting the two sites using the sites_to_bond function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1_2 = sites_to_bond(1, 2, honeycomb, lattice)\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 2]\ndisplacement = [0, 0]\n\njulia> bond_1_3 = sites_to_bond(1, 3, honeycomb, lattice)\n[[Bond]]\n\ndimensions   = 2\norbitals     = [1, 1]\ndisplacement = [1, 0]","category":"page"},{"location":"#LatticeUtilities.jl","page":"Home","title":"LatticeUtilities.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the LatticeUtilities.jl package. This package exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install LatticeUtilities.jl run following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add LatticeUtilities","category":"page"}]
}
