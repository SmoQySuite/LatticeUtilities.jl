var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LatticeUtilities]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [LatticeUtilities]","category":"page"},{"location":"api/#LatticeUtilities.Bond","page":"API","title":"LatticeUtilities.Bond","text":"Bond\n\nDefines a bond defintion in lattice.\n\nFields\n\nD::Int64\n\n: Dimension of system bond is in.\n\norbitals::Tuple{Int64, Int64}\n\n: Initial and final orbital species respectively.\n\ndisplacement::Vector{Int64}\n\n: Displacement in unit cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.Bond-Tuple{AbstractVector{Int64}, AbstractVector{Int64}}","page":"API","title":"LatticeUtilities.Bond","text":"Bond(orbitals::AbstractVector{Int}, displacement::AbstractVector{Int})\n\nConstrcut a Bond\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.Bond-Tuple{Tuple{Int64, Int64}, AbstractVector{Int64}}","page":"API","title":"LatticeUtilities.Bond","text":"Bond(orbitals::Tuple{Int,Int}, displacement::AbstractVector{Int})\n\nConstrcut a Bond\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.Lattice","page":"API","title":"LatticeUtilities.Lattice","text":"Lattice\n\nA type defining a finite lattice in arbitary dimensions.\n\nFields\n\nD::Int64\n\n: Number of spatial dimensions.\n\nN::Int64\n\n: Number of unit cells.\n\nL::Vector{Int64}\n\n: Linear extent of lattice in the direction of each lattice vector.\n\nperiodic::Vector{Bool}\n\n: Whether the lattice is periodic in the direction of each lattice vector.\n\nlvec::Vector{Int64}\n\n: Storage space for representing a location or displacement in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.Lattice-Tuple{Vector{Int64}, Vector{Bool}}","page":"API","title":"LatticeUtilities.Lattice","text":"Lattice(L::Vector{Int}, periodic::Vector{Bool})\n\nConstructs a Lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.UnitCell","page":"API","title":"LatticeUtilities.UnitCell","text":"UnitCell{T<:AbstractFloat}\n\nA type defining a unit cell.\n\nFields\n\nD::Int64\n\n: Number of spatial dimensions.\n\nn::Int64\n\n: Orbitals per unit cell.\n\nlattice_vecs::Matrix{T} where T<:AbstractFloat\n\n: Matrix where the columns are the lattice vectors.\n\nreciprocal_vecs::Matrix{T} where T<:AbstractFloat\n\n: Matrix where the columns are the reciprocal lattice vectors.\n\nbasis_vecs::Matrix{T} where T<:AbstractFloat\n\n: Matrix where the columns are then basis vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#LatticeUtilities.UnitCell-Union{Tuple{T}, Tuple{AbstractArray{Vector{T}, 1}, AbstractArray{Vector{T}, 1}}} where T<:AbstractFloat","page":"API","title":"LatticeUtilities.UnitCell","text":"UnitCell(lattice_vecs::AbstractVector{Vector{T}}, basis_vecs::AbstractVector{Vector{T}})\n    where {T<:AbstractFloat}\n\nConstrcuts a UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.UnitCell-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:AbstractFloat","page":"API","title":"LatticeUtilities.UnitCell","text":"UnitCell(lattice_vecs::Matrix{T}, basis_vecs::Matrix{T}) where {T<:AbstractFloat}\n\nConstrcuts a UnitCell.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Bond, Bond}","page":"API","title":"Base.:==","text":"Base.:==(b₁::Bond,b₂::Bond)\n\nTests if two bonds b₁ and b₂ are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, Bond}","page":"API","title":"Base.show","text":"Base.show(io::IO, bond::Bond)\nBase.show(io::IO, ::MIME\"text/plain\", bond::Bond)\n\nShow lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, Lattice}","page":"API","title":"Base.show","text":"Base.show(io::IO, lattice::Lattice)\nBase.show(io::IO, ::MIME\"text/plain\", lattice::Lattice)\n\nShow lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Union{Tuple{T}, Tuple{IO, UnitCell{T}}} where T","page":"API","title":"Base.show","text":"Base.show(io::IO, uc::UnitCell{T}) where {T}\nBase.show(io::IO, ::MIME\"text/plain\", uc::UnitCell{T}) where {T}\n\nShow unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.bond_to_vec!-Union{Tuple{T}, Tuple{AbstractVector{T}, Bond, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.bond_to_vec!","text":"bond_to_vec!(Δr::AbstractVector{T}, bond::Bond, unit_cell::UnitCell{T}) where {T}\n\nCalculate the displacement vector associated with a bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.bond_to_vec-Union{Tuple{T}, Tuple{Bond, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.bond_to_vec","text":"bond_to_vec(bond::Bond, unit_cell::UnitCell{T})\n\nReturn the displacement vector associated with a bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.build_neighbor_table-Tuple{AbstractVector{Bond}, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.build_neighbor_table","text":"build_neighbor_table(bonds::AbstractVector{Bond}, unit_cell::UnitCell, lattice::Lattice)\n\nConstruct the neighbor table corresponding to bonds.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.build_neighbor_table-Tuple{Bond, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.build_neighbor_table","text":"build_neighbor_table(bond::Bond, unit_cell::UnitCell, lattice::Lattice)\n\nConstruct the neighbor table corresponding to bond.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_point!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Int64}, UnitCell{T}, Lattice}} where T","page":"API","title":"LatticeUtilities.calc_k_point!","text":"calc_k_point!(k_point::AbstractVector{T}, k_loc::AbstractVector{Int},\n    unit_cell::UnitCell{T}, lattice::Lattice) where {T}\n\nCalculate the k-point k_point corresponding to the k-point location k_loc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_point-Union{Tuple{T}, Tuple{AbstractVector{Int64}, UnitCell{T}, Lattice}} where T","page":"API","title":"LatticeUtilities.calc_k_point","text":"calc_k_point(k_point::AbstractVector{T}, k_loc::AbstractVector{Int},\n    unit_cell::UnitCell{T}, lattice::Lattice) where {T}\n\nReturn the k-point k_point corresponding to the k-point location k_loc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_points!-Union{Tuple{T}, Tuple{AbstractArray{T}, UnitCell{T}, Lattice}} where T","page":"API","title":"LatticeUtilities.calc_k_points!","text":"calc_k_points!(k_points::AbstractArray{T}, unit_cell::UnitCell{T},\n    lattice::Lattice) where {T}\n\nCalculate the k-point grid k_points assicated with a finite lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.calc_k_points-Union{Tuple{T}, Tuple{UnitCell{T}, Lattice}} where T","page":"API","title":"LatticeUtilities.calc_k_points","text":"calc_k_points!(unit_cell::UnitCell{T}, lattice::Lattice) where {T}\n\nReturn the k-point grid assicated with a finite lattice. For a D dimensional lattice, a D+1 dimensional array will be returned. If the system has open boundary conditions in a given direction, it will treat the linear extent of the system in that direction as equalling L=1 for the purposes of calucting the k-points.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.displacement_to_vec!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Int64}, Int64, Int64, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.displacement_to_vec!","text":"displacement_to_vec!(Δr::AbstractVector{T}, Δl::AbstractVector{Int},\n    o₁::Int, o₂::Int, unit_cell::UnitCell{T}) where {T}\n\nComputes the position space displacement vector Δr corresponding to a displacement definition given by initial and final orbitals o₁ and o₂ in the unit cell respectively, along with a displacement in unit cells Δl.\n\nArguments\n\nΔr::AbstractVector{T}: displacement vector in position space.\nΔl::AbstractVector{Int}: displacement in unit cells.\no₁::Int: initial orbital in unit cell.\no₂::Int: final orbital in unit cell.\nunit_cell::UnitCell{T}: unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.displacement_to_vec-Union{Tuple{T}, Tuple{AbstractVector{Int64}, Int64, Int64, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.displacement_to_vec","text":"displacement_to_vec(Δl::AbstractVector{Int}, o₁::Int, o₂::Int,\n    unit_cell::UnitCell{T}) where {T}\n\nReturns the position space displacement vector Δr corresponding to a displacement definition given by initial and final orbitals o₁ and o₂ in the unit cell respectively, along with a displacement in unit cells Δl.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.get_num_sites-Tuple{UnitCell, Lattice}","page":"API","title":"LatticeUtilities.get_num_sites","text":"get_num_sites(unit_cell::UnitCell, lattice::Lattice)\n\nReturns the number of sites Nₛ in a finite lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Int64}, Int64, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.loc_to_pos!","text":"loc_to_pos!(r::AbstractVector{T}, l::AbstractVector{Int}, s::Int,\n    unit_cell::UnitCell{T}) where {T}\n\nCalculate the position r of a orbital o at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Int64}, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.loc_to_pos!","text":"loc_to_pos!(r::AbstractVector{T}, l::AbstractVector{Int},\n    unit_cell::UnitCell{T}) where {T}\n\nCalculate the position r of a unit cell at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos-Union{Tuple{T}, Tuple{AbstractVector{Int64}, Int64, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.loc_to_pos","text":"loc_to_pos(l::AbstractVector{Int}, s::Int, unit_cell::UnitCell{T})\n    where {T}\n\nReturn the position r of a orbital o at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_pos-Union{Tuple{T}, Tuple{AbstractVector{Int64}, UnitCell{T}}} where T","page":"API","title":"LatticeUtilities.loc_to_pos","text":"loc_to_pos(l::AbstractVector{Int}, unit_cell::UnitCell{T})\n    where {T}\n\nReturn the position r of a unit cell at location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_site-Tuple{AbstractVector{Int64}, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.loc_to_site","text":"loc_to_site(l::AbstractVector{Int}, o::Int, unit_cell::UnitCell, lattice::Lattice)\n\nGiven a unit cell location l and orbital species o, return the corresponding site s in the lattice. If the location is not valid owing to open boundary conditions then return s = 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_site-Tuple{Int64, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.loc_to_site","text":"loc_to_site(u::Int, o::Int, unit_cell::UnitCell, lattice::Lattice)\n\nGiven a unit cell index u and orbital o, return the correspond site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.loc_to_unitcell-Tuple{AbstractVector{Int64}, Lattice}","page":"API","title":"LatticeUtilities.loc_to_unitcell","text":"loca_to_unitcell(l::AbstractVector{Int}, lattice::Lattice)\n\nReturn the unit cell found at location l in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.map_neighbor_table-Tuple{Matrix{Int64}}","page":"API","title":"LatticeUtilities.map_neighbor_table","text":"map_neighbor_table(neighbor_table::Matrix{Int})\n\nFor a given neighbor table, return a dictionary that reports the bonds and neighbors associated with each site in the lattice. If neighbor_table is modified, then a new map must be constructed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.pbc!-Tuple{AbstractVector{Int64}, Lattice}","page":"API","title":"LatticeUtilities.pbc!","text":"pbc!(l::AbstractVector{Int}, lattice::Lattice)\n\nApply periodic boundary to unit cell location l.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.simplify!-Tuple{AbstractVector{Int64}, Lattice}","page":"API","title":"LatticeUtilities.simplify!","text":"simplify!(Δl::AbstractVector{Int}, lattice::Lattice)\n\nSimplify displacement Δl so that it is as short as possible accounting for periodic boundary conditions where necessary.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.simplify!-Tuple{Bond, Lattice}","page":"API","title":"LatticeUtilities.simplify!","text":"simplify!(bond::Bond, lattice::Lattice)\n\nSimplify a bond so that the displacement is the shortest possible accounting for periodic boundary conditions where necessary.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_loc!-Tuple{AbstractVector{Int64}, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.site_to_loc!","text":"site_to_loc!(l::AbstractVector{Int}, s::Int, unit_cell::UnitCell, lattice::Lattice)\n\nFor a given site s in the lattice, calculate the location l of the unit cell it is in and return the orbital species o of the site.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_loc-Tuple{Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.site_to_loc","text":"site_to_loc(s::Int, unit_cell::UnitCell, lattice::Lattice)\n\nFor a given site s in the lattice, return the location l of the unit cell it is in and the orbital species o.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_orbital-Tuple{Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.site_to_orbital","text":"site_to_orbital(s::Int, unit_cell::UnitCell, lattice::Lattice)\n\nReturn the orbtial species of site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_site-Tuple{Int64, AbstractVector{Int64}, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.site_to_site","text":"site_to_site(s₁::Int, Δl::AbstractVector{Int}, o₂::Int, unit_cell::UnitCell, lattice::Lattice)\n\nGiven an initial site s₁, and a displacement in unit cells Δl and a terminating orbital species o₂, return the resulting site s₂ in the lattice. If the displacement is not allowed as a result of open boundary conditions, then  s₂=0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.site_to_unitcell-Tuple{Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.site_to_unitcell","text":"site_to_unitcell(s::Int, unit_cell::UnitCell, lattice::Lattice)\n\nReturn the unit cell u containing lattice site s.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_bond!-Tuple{Bond, Int64, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.sites_to_bond!","text":"sites_to_bond!(bond::Bond, s₁::Int, s₂::Int, unit_cell::UnitCell, lattice::Lattice)\n\nCalculate the bond associated with getting displaced from site s₁ to s₂. \n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_bond-Tuple{Int64, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.sites_to_bond","text":"sites_to_bond(s₁::Int, s₂::Int, unit_cell::UnitCell, lattice::Lattice)\n\nReturn the bond associated with getting displaced from site s₁ to s₂. \n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_displacement!-Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.sites_to_displacement!","text":"function sites_to_displacement!(o::AbstractVector{Int}, Δl::AbstractVector{Int},\n    s₁::Int, s₂::Int, unit_cell::UnitCell, lattice::Lattice)\n\nWhen getting displaced from site s₁ to s₂, calculate the initial and final orbitals o and displacement in unit cells Δl.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.sites_to_displacement-Tuple{Int64, Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.sites_to_displacement","text":"function sites_to_displacement(s₁::Int, s₂::Int, unit_cell::UnitCell, lattice::Lattice)\n\nWhen getting displaced from site s₁ to s₂, return the initial and final orbitals o and displacement in unit cells Δl.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.translational_avg!-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, AbstractArray{Complex{T}}, AbstractArray{Complex{T}}}} where T<:AbstractFloat","page":"API","title":"LatticeUtilities.translational_avg!","text":"function translational_avg!(fg::AbstractArray{Complex{T}}, f::AbstractArray{Complex{T}},\n    g::AbstractArray{Complex{T}}; restore::Bool=true) where {T<:AbstractFloat}\n\nLet f[i] and g[j] be two distinct multi-dimensional arrays, where i and j represent an index into them and also correspond to the position of a unit cell in a periodic finite lattice This method then computes in-place the product (f⋅g)[i-j] that is averaged over translation symmetry. If restore = true then f and g are left unchanged, otherwise they will be left modified.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.unitcell_to_loc!-Tuple{AbstractVector{Int64}, Int64, Lattice}","page":"API","title":"LatticeUtilities.unitcell_to_loc!","text":"unitcell_to_loc!(l::AbstractVector{Int}, u::Int, lattice::Lattice)\n\nCalculate the location l of a unit cell u.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.unitcell_to_loc-Tuple{Int64, Lattice}","page":"API","title":"LatticeUtilities.unitcell_to_loc","text":"unitcell_to_loc(u::Int, lattice::Lattice)\n\nReturn the location of unit cell u.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.valid_loc-Tuple{AbstractVector{Int64}, Lattice}","page":"API","title":"LatticeUtilities.valid_loc","text":"valid_location(l::AbstractVector{Int}, lattice::Lattice)\n\nDetermine if l describes a valid location in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeUtilities.valid_site-Tuple{Int64, UnitCell, Lattice}","page":"API","title":"LatticeUtilities.valid_site","text":"valid_site(s::Int, unit_cell::UnitCell, lattice::Lattice)\n\nReturn whether s is a valid site index.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First the LatticeUtilities.jl package needs to be imported.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using LatticeUtilities","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As an initial example, we construct an instance of the UnitCell type to represent the unit cell for a square lattice:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> square = UnitCell(lattice_vecs = [[1.,0.],[0.,1.]],\n                         basis_vecs   = [[0.,0.]])\nUnitCell{Float64}:\n • D = 2\n • n = 1\n • lattice_vecs =\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n • reciprocal_vecs =\n2×2 Matrix{Float64}:\n 6.28319  0.0\n 0.0      6.28319\n • basis_vecs =\n2×1 Matrix{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next we construct an instance of the type Lattice that describes the size of a finite lattice for a given unit cell definition. In the example below we assume periodic boundary conditions in the direction of both lattice vectors:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> lattice = Lattice(L = [4,4], periodic = [true,true])\nLattice:\n • D = 2\n • N = 16\n • L = [4, 4]\n • periodic = Bool[1, 1]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Bonds (or edges) in a lattice are represented by the Bond type. Considering just nearest neighbors, there are two bonds that need to be defined:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> bond_x = Bond(orbitals = [1,1], displacement = [1,0])\nBond:\n • D = 2\n • orbitals = (1, 1)\n • displacement = [1, 0]\n\njulia> bond_y = Bond([1,1], [0,1])\nBond:\n • D = 2\n • orbitals = (1, 1)\n • displacement = [0, 1]","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Using these two bond definitions, we can construct the corresponding neighbor table using the build_neighbor_table method:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> neighbor_table = build_neighbor_table([bond_x,bond_y], square, lattice)\n2×32 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …   8   9  10  11  12  13  14  15  16\n 2  3  4  1  6  7  8  5  10  11  12     12  13  14  15  16   1   2   3   4","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page includes several examples on how to use the LatticeUtilities.jl package.","category":"page"},{"location":"examples/#Kagome-Lattice","page":"Examples","title":"Kagome Lattice","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"As a first example we will represent a Kagome lattice. The lattice vectors for the Kagome lattice are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfa_1 = left(10right)\nmathbfa_2 = left(frac12fracsqrt32right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and with three orbitals per unit cell, the basis vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfr_rm 1 = left(00right)\nmathbfr_rm 2 = left(frac120right)\nmathbfr_rm 3 = left(frac14fracsqrt34right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The reciprocal lattice vectors are then","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfb_1 = 2pi left(1-frac1sqrt3right)\nmathbfb_2 = 2pi left(0frac2sqrt3right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We begin by constructing an instance of the type UnitCell to represent the Kagome lattice unit cell:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> kagome = UnitCell(lattice_vecs = [[1.0,0.0], [1/2,√3/2]],\n                         basis_vecs   = [[0.0,0.0], [1/2,0.0], [1/4,√3/4]])\nUnitCell{Float64}:\n • D = 2\n • n = 3\n • lattice_vecs =\n2×2 Matrix{Float64}:\n 1.0  0.5\n 0.0  0.866025\n • reciprocal_vecs =\n2×2 Matrix{Float64}:\n  6.28319  0.0\n -3.6276   7.2552\n • basis_vecs =\n2×3 Matrix{Float64}:\n 0.0  0.5  0.25\n 0.0  0.0  0.433013","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is straightforward to calculate position space vectors of the form mathbfr = n_1 mathbfa_1 + n_2 mathbfa_2 + mathbfr_alpha using the method loc_to_pos, where mathbfr_alpha is one of the three possible basis vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> n₁,n₂,α = 1,1,2\n(1, 1, 2)\n\njulia> loc_to_pos([n₁,n₂],α,kagome)\n2-element Vector{Float64}:\n 2.0\n 0.8660254037844386","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Displacement vectors of the form mathbfr = n_1 mathbfa_1 + n_2 mathbfa_2 + (mathbfr_beta - mathbfr_alpha) can also be calculate using the displacement_to_vec method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> n₁,n₂,α,β = 1,1,2,3\n(1, 1, 2, 3)\n\njulia> displacement_to_vec([n₁,n₂],α,β,kagome)\n2-element Vector{Float64}:\n 1.25\n 1.299038105676658","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that there are memory allocation free variants of many methods, such as loc_to_pos! and displacement_to_vec!, with names ending in ! that work by modifying the first array argument in place.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next step is to construct an instance of the type Lattice, which can be used in conjunction with a UnitCell instance of like dimension D, to represent a finite lattice. In this example we will consider a 3 times 3 unit cell Kagome lattice with periodic boundary conditions in the direction of both lattice vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice = Lattice(L = [3,3], periodic = [true,true])\nLattice:\n • D = 2\n • N = 9\n • L = [3, 3]\n • periodic = Bool[1, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Given an initial site, a displacement in unit cells, and a terminating orbital species, we can calculate the final site using the site_to_site method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> site_to_site(17, [1,1], 2, kagome, lattice)\n20","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The set of relevant mathbfk-points associated with a finite lattice in three dimensions is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mathbfk = fracn_1L_1mathbfb_1 + fracn_2L_2mathbfb_2 + fracn_3L_3mathbfb_3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where each index runs from n_i = 0 1 dots L_i-1.\nThis set of mathbfk-points can be constructed using the calc_k_points method:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> calc_k_points(kagome,lattice)\n2×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.0   2.0944   4.18879\n 0.0  -1.2092  -2.4184\n\n[:, :, 2] =\n 0.0     2.0944   4.18879\n 2.4184  1.2092  -1.34248e-16\n\n[:, :, 3] =\n 0.0     2.0944  4.18879\n 4.8368  3.6276  2.4184","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Individual mathbfk-points can be calculated using the calc_k_point and calc_k_point! methods.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we concern ourselves with just nearest neighbor bonds, we need to define six instances of Bond type:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 = Bond(orbitals = [1,2], displacement = [0,0])\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [0, 0]\n\njulia> bond_2 = Bond([1,3], [0,0])\nBond:\n • D = 2\n • orbitals = (1, 3)\n • displacement = [0, 0]\n\njulia> bond_3 = Bond([2,3], [0,0])\nBond:\n • D = 2\n • orbitals = (2, 3)\n • displacement = [0, 0]\n\njulia> bond_4 = Bond([2,1], [1,0])\nBond:\n • D = 2\n • orbitals = (2, 1)\n • displacement = [1, 0]\n\njulia> bond_5 = Bond([3,1], [0,1])\nBond:\n • D = 2\n • orbitals = (3, 1)\n • displacement = [0, 1]\n\njulia> bond_6 = Bond([3,2], [-1,1])\nBond:\n • D = 2\n • orbitals = (3, 2)\n • displacement = [-1, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we are ready to build the corresponding neighbor table:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> neighbor_table = build_neighbor_table([bond_1, bond_2, bond_3,\n                                              bond_4, bond_5, bond_6],\n                                              kagome, lattice)\n2×54 Matrix{Int64}:\n 1  4  7  10  13  16  19  22  25  1  4  …   3   6   9  12  15  18  21  24  27\n 2  5  8  11  14  17  20  23  26  3  6     17  11  14  26  20  23   8   2   5","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It is frequently useful to have a reference that lists the neighbors associated with each site in the lattice, as well as the bonds, which are specified by a column index into neighbor_table. This information is returned by the function map_neighbor_table:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> neighbor_table_map = map_neighbor_table(neighbor_table)\nDict{Int64, NamedTuple{(:bonds, :neighbors), Tuple{Vector{Int64}, Vector{Int64}}}} with 27 entries:\n  5  => (bonds = [2, 20, 29, 54], neighbors = [4, 6, 7, 27])\n  16 => (bonds = [6, 15, 32, 39], neighbors = [17, 18, 14, 9])\n  20 => (bonds = [7, 25, 34, 50], neighbors = [19, 21, 22, 15])\n  12 => (bonds = [13, 22, 40, 49], neighbors = [10, 11, 19, 26])\n  24 => (bonds = [17, 26, 44, 53], neighbors = [22, 23, 4, 2])\n  8  => (bonds = [3, 21, 30, 52], neighbors = [7, 9, 1, 21])\n  17 => (bonds = [6, 24, 33, 46], neighbors = [16, 18, 10, 3])\n  1  => (bonds = [1, 10, 30, 43], neighbors = [2, 3, 8, 21])\n  19 => (bonds = [7, 16, 36, 40], neighbors = [20, 21, 26, 12])\n  22 => (bonds = [8, 17, 34, 41], neighbors = [23, 24, 20, 15])\n  23 => (bonds = [8, 26, 35, 51], neighbors = [22, 24, 25, 18])\n  6  => (bonds = [11, 20, 38, 47], neighbors = [4, 5, 13, 11])\n  11 => (bonds = [4, 22, 31, 47], neighbors = [10, 12, 13, 6])\n  9  => (bonds = [12, 21, 39, 48], neighbors = [7, 8, 16, 14])\n  14 => (bonds = [5, 23, 32, 48], neighbors = [13, 15, 16, 9])\n  3  => (bonds = [10, 19, 37, 46], neighbors = [1, 2, 10, 17])\n  7  => (bonds = [3, 12, 29, 45], neighbors = [8, 9, 5, 27])\n  25 => (bonds = [9, 18, 35, 42], neighbors = [26, 27, 23, 18])\n  4  => (bonds = [2, 11, 28, 44], neighbors = [5, 6, 2, 24])\n  ⋮  => ⋮","category":"page"},{"location":"examples/#Cubic-Lattice-and-Boundary-Conditions","page":"Examples","title":"Cubic Lattice and Boundary Conditions","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we consider a simple cubic lattice. As usual, we begin by defining a UnitCell:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> cubic = UnitCell(lattice_vecs = [[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]],\n                        basis_vecs   = [[0.,0.,0.]])\nUnitCell{Float64}:\n • D = 3\n • n = 1\n • lattice_vecs =\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n • reciprocal_vecs =\n3×3 Matrix{Float64}:\n 6.28319  0.0      0.0\n 0.0      6.28319  0.0\n 0.0      0.0      6.28319\n • basis_vecs =\n3×1 Matrix{Float64}:\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next we define four instances of the type Lattice. The first one represents a lattice that is periodic in the direction of all three lattice vectors:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ppp = Lattice([4,4,4],[true,true,true])\nLattice:\n • D = 3\n • N = 64\n • L = [4, 4, 4]\n • periodic = Bool[1, 1, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The second defines a lattice that is periodic only in the direction of the first two lattice vectors, hatmathbfx and hatmathbfy:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ppo = Lattice([4,4,4],[true,true,false])\nLattice:\n • D = 3\n • N = 64\n • L = [4, 4, 4]\n • periodic = Bool[1, 1, 0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The third defines a lattice that is periodic only in the direction of the first lattice vector, hatmathbfx:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_poo = Lattice([4,4,4],[true,false,false])\nLattice:\n • D = 3\n • N = 64\n • L = [4, 4, 4]\n • periodic = Bool[1, 0, 0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lastly, we define a lattice with strictly open boundary conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice_ooo = Lattice([4,4,4],[false,false,false])\nLattice:\n • D = 3\n • N = 64\n • L = [4, 4, 4]\n • periodic = Bool[0, 0, 0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the set of mathbfk-points generated by the function calc_k_points changes with the boundary conditions. In particular, if a lattice has open boundary conditions in the direction of the lattice vector mathbfa_i, then it treats L_i = 1 when calculating the relevant set of mathbfk-points associated with a lattice:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> size( calc_k_points(cubic,lattice_ppp) )\n(3, 4, 4, 4)\n\njulia> size( calc_k_points(cubic,lattice_ppo) )\n(3, 4, 4, 1)\n\njulia> size( calc_k_points(cubic,lattice_poo) )\n(3, 4, 1, 1)\n\njulia> size( calc_k_points(cubic,lattice_ooo) )\n(3, 1, 1, 1)\n\njulia> calc_k_points(cubic,lattice_ooo)\n3×1×1×1 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As you can see, in the case that the lattice only has open boundary conditions, then just the mathbfk = 0 point is returned.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next we will consider how the boundary conditions effect how neighbor tables are computed. Considering just nearest neighbors, we have three bonds to define:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_x = Bond(orbitals = [1,1], displacement = [1,0,0])\nBond:\n • D = 3\n • orbitals = (1, 1)\n • displacement = [1, 0, 0]\n\njulia> bond_y = Bond([1,1], [0,1,0])\nBond:\n • D = 3\n • orbitals = (1, 1)\n • displacement = [0, 1, 0]\n\njulia> bond_z = Bond([1,1], [0,0,1])\nBond:\n • D = 3\n • orbitals = (1, 1)\n • displacement = [0, 0, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Base on these three bonds, the neighbor table generated using build_neighbor_table will depend on the boundary conditions used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nt_ppp = build_neighbor_table([bond_x,bond_y,bond_z],\n                                      cubic, lattice_ppp)\n2×192 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  56  57  58  59  60  61  62  63  64\n 2  3  4  1  6  7  8  5  10  11  12      8   9  10  11  12  13  14  15  16\n\njulia> nt_ppo = build_neighbor_table([bond_x,bond_y,bond_z],\n                                      cubic, lattice_ppo)\n2×176 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  40  41  42  43  44  45  46  47  48\n 2  3  4  1  6  7  8  5  10  11  12     56  57  58  59  60  61  62  63  64\n\njulia> nt_poo = build_neighbor_table([bond_x,bond_y,bond_z],\n                                      cubic, lattice_poo)\n2×160 Matrix{Int64}:\n 1  2  3  4  5  6  7  8   9  10  11  …  40  41  42  43  44  45  46  47  48\n 2  3  4  1  6  7  8  5  10  11  12     56  57  58  59  60  61  62  63  64\n\njulia> nt_ooo = build_neighbor_table([bond_x,bond_y,bond_z],\n                                      cubic, lattice_ooo)\n2×144 Matrix{Int64}:\n 1  2  3  5  6  7   9  10  11  13  14  …  40  41  42  43  44  45  46  47  48\n 2  3  4  6  7  8  10  11  12  14  15     56  57  58  59  60  61  62  63  64","category":"page"},{"location":"examples/#Honeycomb-Lattice-and-Bond-Operations","page":"Examples","title":"Honeycomb Lattice and Bond Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we consider the Honeycomb, or Hexagonal, lattice with just nearest neighbor interactions. The lattice vectors for the honeycomb lattice are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfa_1 =\tleft(frac32fracsqrt32right)\nmathbfa_2 =\tleft(frac32-fracsqrt32right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and basis vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfr_1 =\tleft(00right)\nmathbfr_2 =\tleft(10right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The corresponding reciprocal lattice vectors are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nmathbfb_1 =\t2pileft(frac13fracsqrt33right)\nmathbfb_2 =\t2pileft(frac13-fracsqrt33right)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As usual, we begin by constructing an instance of the type UnitCell to reflect this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> honeycomb = UnitCell(lattice_vecs = [[3/2,√3/2],[3/2,-√3/2]],\n                            basis_vecs   = [[0.,0.],[1.,0.]])\nUnitCell{Float64}:\n • D = 2\n • n = 2\n • lattice_vecs =\n2×2 Matrix{Float64}:\n 1.5        1.5\n 0.866025  -0.866025\n • reciprocal_vecs =\n2×2 Matrix{Float64}:\n 2.0944   2.0944\n 3.6276  -3.6276\n • basis_vecs =\n2×2 Matrix{Float64}:\n 0.0  1.0\n 0.0  0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And again, we define an instance of the type Lattice to represent a finite lattice:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> lattice = Lattice([3,3],[true,true])\nLattice:\n • D = 2\n • N = 9\n • L = [3, 3]\n • periodic = Bool[1, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we consider just nearest neighbor relations, three types of bonds need to be defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 = Bond(orbitals = [1,2], displacement = [0,0])\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [0, 0]\n\njulia> bond_2 = Bond([1,2], [-1,0])\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [-1, 0]\n\njulia> bond_3 = Bond([1,2], [0,-1])\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [0, -1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"However, these three bond definitions are not unique. For instance, it would be similarly correct to define the nearest neighbor relations using these three bond definitions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1′ = Bond(orbitals = [2,1], displacement = [0,0])\nBond:\n • D = 2\n • orbitals = (2, 1)\n • displacement = [0, 0]\n\njulia> bond_2′ = Bond([2,1], [1,0])\nBond:\n • D = 2\n • orbitals = (2, 1)\n • displacement = [1, 0]\n\njulia> bond_3′ = Bond([2,1], [0,1])\nBond:\n • D = 2\n • orbitals = (2, 1)\n • displacement = [0, 1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"While the explicit definitions are different here, we can test for equivalencies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1 == bond_1′\ntrue\n\njulia> bond_2 == bond_2′\ntrue\n\njulia> bond_3 == bond_3′\ntrue\n\njulia> bond_1 == bond_2′\nfalse","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that while not explicitly enforced, for comparison operations like this to be valid each bond definition need to be defined assuming shared lattice vector definitions, which themselves are not unique.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that is also possible to simplify! a bond, accounting for the size of a finite lattice and also periodic boundary conditions where necessary:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond′ = Bond([1,2],[2,0])\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [2, 0]\n\njulia> simplify!(bond′,lattice)\n\njulia> bond′\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [-1, 0]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lastly, given a pair of sites in a finite lattice, it is very easy to determine the bond definition connecting the two sites using the sites_to_bond function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> bond_1_2 = sites_to_bond(1, 2, honeycomb, lattice)\nBond:\n • D = 2\n • orbitals = (1, 2)\n • displacement = [0, 0]\n\njulia> bond_1_3 = sites_to_bond(1, 3, honeycomb, lattice)\nBond:\n • D = 2\n • orbitals = (1, 1)\n • displacement = [1, 0]","category":"page"},{"location":"#LatticeUtilities.jl","page":"Home","title":"LatticeUtilities.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the LatticeUtilities.jl package. This package exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install LatticeUtilities.jl run following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add LatticeUtilities","category":"page"}]
}
